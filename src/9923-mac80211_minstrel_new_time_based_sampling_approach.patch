--- a/net/mac80211/rc80211_minstrel.h
+++ b/net/mac80211/rc80211_minstrel.h
@@ -23,6 +23,12 @@
 /* number of highest throughput rates to consider*/
 #define MAX_THR_RATES 4
 
+/* rate sampling interval in milliseconds */
+#define RATE_SAMPLING_INT 20
+
+/* minimum number of packets between two successive sample attempts */
+#define MIN_INTERSAMPLE_SPACING 1
+
 /*
  * Perform EWMA (Exponentially Weighted Moving Average) calculation
  */
@@ -82,8 +88,6 @@ struct minstrel_rate {
 	unsigned int perfect_tx_time;
 	unsigned int ack_time;
 
-	int sample_limit;
-
 	struct minstrel_rate_stats stats;
 };
 
@@ -91,6 +95,7 @@ struct minstrel_sta_info {
 	struct ieee80211_sta *sta;
 
 	unsigned long last_stats_update;
+	unsigned long last_rate_update;
 	unsigned int sp_ack_dur;
 	unsigned int rate_avg;
 
@@ -98,16 +103,15 @@ struct minstrel_sta_info {
 
 	u8 max_tp_rate[MAX_THR_RATES];
 	u8 max_prob_rate;
+	u8 cur_rc_intersample_spacing;
 	unsigned int total_packets;
 	unsigned int sample_packets;
-	int sample_deferred;
 
 	unsigned int sample_row;
 	unsigned int sample_column;
 
 	int n_rates;
 	struct minstrel_rate *r;
-	bool prev_sample;
 
 	/* sampling table */
 	u8 *sample_table;
@@ -115,14 +119,11 @@ struct minstrel_sta_info {
 
 struct minstrel_priv {
 	struct ieee80211_hw *hw;
-	bool has_mrr;
 	unsigned int cw_min;
 	unsigned int cw_max;
 	unsigned int max_retry;
 	unsigned int segment_size;
-	unsigned int update_interval;
-	unsigned int lookaround_rate;
-	unsigned int lookaround_rate_mrr;
+	bool has_mrr;
 
 	u8 cck_rates[4];
 
--- a/net/mac80211/rc80211_minstrel.c
+++ b/net/mac80211/rc80211_minstrel.c
@@ -88,6 +88,33 @@ int minstrel_get_tp_avg(struct minstrel_
 		return MINSTREL_TRUNC(100000 * (prob_ewma / usecs));
 }
 
+/* Check whether rate sampling is required */
+static inline bool
+minstrel_requires_sampling(struct minstrel_sta_info *mi,
+			   struct minstrel_priv *mp,
+			   bool mrr_capable)
+{
+	int rate_sampling_interval;
+	int intersample_delta;
+
+	/* Check multi-rate-retry capabilities & adjust sampling interval */
+	if (mrr_capable)
+		rate_sampling_interval = RATE_SAMPLING_INT;
+	else
+		rate_sampling_interval = RATE_SAMPLING_INT * 2;
+
+	intersample_delta = mi->sample_packets - mi->cur_rc_intersample_spacing;
+	if (intersample_delta >= MIN_INTERSAMPLE_SPACING &&
+	    (time_after(jiffies, mi->last_rate_update +
+	    (rate_sampling_interval * HZ) / 1000))) {
+		mi->cur_rc_intersample_spacing = mi->sample_packets;
+		mi->last_rate_update = jiffies;
+		return true;
+	} else {
+		return false;
+	}
+}
+
 /* find & sort topmost throughput rates */
 static inline void
 minstrel_sort_best_tp_rates(struct minstrel_sta_info *mi, int i, u8 *tp_list)
@@ -220,9 +247,7 @@ minstrel_update_stats(struct minstrel_pr
 			mr->adjusted_retry_count = mrs->retry_count >> 1;
 			if (mr->adjusted_retry_count > 2)
 				mr->adjusted_retry_count = 2;
-			mr->sample_limit = 4;
 		} else {
-			mr->sample_limit = -1;
 			mr->adjusted_retry_count = mrs->retry_count;
 		}
 		if (!mr->adjusted_retry_count)
@@ -297,11 +322,8 @@ minstrel_tx_status(void *priv, struct ie
 	if ((info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) && (i >= 0))
 		mi->sample_packets++;
 
-	if (mi->sample_deferred > 0)
-		mi->sample_deferred--;
-
 	if (time_after(jiffies, mi->last_stats_update +
-				(mp->update_interval * HZ) / 1000))
+				(RATE_SAMPLING_INT * 3 * HZ) / 1000))
 		minstrel_update_stats(mp, mi);
 }
 
@@ -319,7 +341,6 @@ minstrel_get_retry_count(struct minstrel
 	return retry;
 }
 
-
 static int
 minstrel_get_next_sample(struct minstrel_sta_info *mi)
 {
@@ -343,27 +364,16 @@ minstrel_get_rate(void *priv, struct iee
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct minstrel_sta_info *mi = priv_sta;
 	struct minstrel_priv *mp = priv;
-	struct ieee80211_tx_rate *rate = &info->control.rates[0];
+	struct ieee80211_tx_rate *sampling_setup = NULL;
 	struct minstrel_rate *msr, *mr;
-	unsigned int ndx;
-	bool mrr_capable;
-	bool prev_sample;
-	int delta;
-	int sampling_ratio;
+	unsigned int sampling_ndx = 0;
+	bool indirect_rate_sampling = false;
+	bool mrr_capable = false;
 
 	/* management/no-ack frames do not use rate control */
 	if (rate_control_send_low(sta, priv_sta, txrc))
 		return;
 
-	/* check multi-rate-retry capabilities & adjust lookaround_rate */
-	mrr_capable = mp->has_mrr &&
-		      !txrc->rts &&
-		      !txrc->bss_conf->use_cts_prot;
-	if (mrr_capable)
-		sampling_ratio = mp->lookaround_rate_mrr;
-	else
-		sampling_ratio = mp->lookaround_rate;
-
 	/* increase sum packet counter */
 	mi->total_packets++;
 
@@ -371,6 +381,7 @@ minstrel_get_rate(void *priv, struct iee
 	if (mi->total_packets == ~0) {
 		mi->sample_packets = 0;
 		mi->total_packets = 0;
+		mi->cur_rc_intersample_spacing = 0;
 	}
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
@@ -383,76 +394,50 @@ minstrel_get_rate(void *priv, struct iee
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
-	delta = (mi->total_packets * sampling_ratio / 100) -
-			(mi->sample_packets + mi->sample_deferred / 2);
+	mrr_capable = mp->has_mrr && !txrc->rts && !txrc->bss_conf->use_cts_prot;
 
-	/* delta < 0: no sampling required */
-	prev_sample = mi->prev_sample;
-	mi->prev_sample = false;
-	if (delta < 0 || (!mrr_capable && prev_sample))
-		return;
-
-	if (mi->total_packets >= 10000) {
-		mi->sample_deferred = 0;
-		mi->sample_packets = 0;
-		mi->total_packets = 0;
-	} else if (delta > mi->n_rates * 2) {
-		/* With multi-rate retry, not every planned sample
-		 * attempt actually gets used, due to the way the retry
-		 * chain is set up - [max_tp,sample,prob,lowest] for
-		 * sample_rate < max_tp.
-		 *
-		 * If there's too much sampling backlog and the link
-		 * starts getting worse, minstrel would start bursting
-		 * out lots of sampling frames, which would result
-		 * in a large throughput loss. */
-		mi->sample_packets += (delta - mi->n_rates * 2);
-	}
-
-	/* get next random rate sample */
-	ndx = minstrel_get_next_sample(mi);
-	msr = &mi->r[ndx];
-	mr = &mi->r[mi->max_tp_rate[0]];
-
-	/* Decide if direct ( 1st mrr stage) or indirect (2nd mrr stage)
-	 * rate sampling method should be used.
-	 * Respect such rates that are not sampled for 20 interations.
-	 */
-	if (mrr_capable &&
-	    msr->perfect_tx_time > mr->perfect_tx_time &&
-	    msr->stats.sample_skipped < 20) {
-		/* Only use IEEE80211_TX_CTL_RATE_CTRL_PROBE to mark
-		 * packets that have the sampling rate deferred to the
-		 * second MRR stage. Increase the sample counter only
-		 * if the deferred sample rate was actually used.
-		 * Use the sample_deferred counter to make sure that
-		 * the sampling is not done in large bursts */
-		info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
-		rate++;
-		mi->sample_deferred++;
-	} else {
-		if (!msr->sample_limit)
+	/* check if rate sampling is required */
+	if (unlikely(minstrel_requires_sampling(mi, mp, mrr_capable))) {
+		/* get next random rate sample */
+		sampling_ndx = minstrel_get_next_sample(mi);
+		msr = &mi->r[sampling_ndx];
+
+		/* If we're not using MRR and the sampling rate already
+		* has a probability of >95%, we shouldn't be attempting
+		* to use it, as this only wastes precious airtime */
+		if (!mrr_capable && (mi->r[sampling_ndx].stats.prob_ewma >
+		    MINSTREL_FRAC(95, 100)))
 			return;
 
-		mi->sample_packets++;
-		if (msr->sample_limit > 0)
-			msr->sample_limit--;
-	}
+		/* current max throughput rate */
+		mr = &mi->r[mi->max_tp_rate[0]];
 
-	/* If we're not using MRR and the sampling rate already
-	 * has a probability of >95%, we shouldn't be attempting
-	 * to use it, as this only wastes precious airtime */
-	if (!mrr_capable &&
-	   (mi->r[ndx].stats.prob_ewma > MINSTREL_FRAC(95, 100)))
+		/* Check if direct (1st mrr stage) or indirect (2nd mrr stage)
+		 * rate sampling method should be used. Enforce rate sampling
+		 * for such rates not sampled within last 20 update cycles. */
+		if (mrr_capable &&
+		    msr->perfect_tx_time > mr->perfect_tx_time &&
+		    msr->stats.sample_skipped < 20)
+			indirect_rate_sampling = true;
+
+		/* setup mrr sampling: indirect -> mrr[1], direct -> mrr[0] */
+		if (indirect_rate_sampling) {
+			info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
+			sampling_setup = &info->control.rates[1];
+		} else {
+			sampling_setup = &info->control.rates[0];
+			mi->sample_packets++;
+		}
+	} else {
+		/* no sampling required */
 		return;
-
-	mi->prev_sample = true;
-
-	rate->idx = mi->r[ndx].rix;
-	rate->count = minstrel_get_retry_count(&mi->r[ndx], info);
+	}
+	/* assign sampling parameter*/
+	sampling_setup->idx = mi->r[sampling_ndx].rix;
+	sampling_setup->count = minstrel_get_retry_count(&mi->r[sampling_ndx],
+	                                                 info);
 }
 
-
 static void
 calc_rate_durations(enum nl80211_band band,
 		    struct minstrel_rate *d,
@@ -542,7 +527,6 @@ minstrel_rate_init(void *priv, struct ie
 
 		/* calculate maximum number of retransmissions before
 		 * fallback (based on maximum segment size) */
-		mr->sample_limit = -1;
 		mrs->retry_count = 1;
 		mr->retry_count_cts = 1;
 		mrs->retry_count_rtscts = 1;
@@ -578,6 +562,7 @@ minstrel_rate_init(void *priv, struct ie
 
 	mi->n_rates = n;
 	mi->last_stats_update = jiffies;
+	mi->last_rate_update = jiffies;
 
 	init_sample_table(mi);
 	minstrel_update_rates(mp, mi);
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -778,7 +778,7 @@ minstrel_ht_tx_status(void *priv, struct
 	}
 
 	if (time_after(jiffies, mi->last_stats_update +
-				(mp->update_interval / 2 * HZ) / 1000)) {
+				(RATE_SAMPLING_INT * 2 * HZ) / 1000)) {
 		update = true;
 		minstrel_ht_update_stats(mp, mi);
 	}
@@ -1193,6 +1193,7 @@ minstrel_ht_update_caps(void *priv, stru
 
 	mi->sta = sta;
 	mi->last_stats_update = jiffies;
+	mi->last_rate_update = jiffies;
 
 	ack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);
 	mi->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1, 0);
@@ -1428,12 +1429,6 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 	mp->cw_min = 15;
 	mp->cw_max = 1023;
 
-	/* number of packets (in %) to use for sampling other rates
-	 * sample less often for non-mrr packets, because the overhead
-	 * is much higher than with mrr */
-	mp->lookaround_rate = 5;
-	mp->lookaround_rate_mrr = 10;
-
 	/* maximum time that the hw is allowed to stay in one MRR segment */
 	mp->segment_size = 6000;
 
@@ -1447,7 +1442,6 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 		mp->has_mrr = true;
 
 	mp->hw = hw;
-	mp->update_interval = 100;
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	mp->fixed_rate_idx = (u32) -1;
